# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WTkYW195S_YQd_YFOD9uf9glKkRG38zo
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import os
import joblib
from tensorflow.keras.models import load_model
from datetime import datetime, timedelta
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import seaborn as sns
import matplotlib.pyplot as plt

# Set page configuration
st.set_page_config(
    page_title="Stock Price Prediction",
    page_icon="ðŸ“ˆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 2.5rem !important;
        color: #1E3A8A;
        text-align: center;
        margin-bottom: 1rem;
    }
    .sub-header {
        font-size: 1.8rem !important;
        color: #3B82F6;
        margin-top: 1.5rem;
        margin-bottom: 1rem;
    }
    .metric-card {
        background-color: #F3F4F6;
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
        box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
    }
    .prediction-card {
        background-color: #EFF6FF;
        border-left: 5px solid #3B82F6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin-bottom: 1rem;
    }
    .file-uploader {
        background-color: #F9FAFB;
        border: 1px dashed #D1D5DB;
        border-radius: 0.5rem;
        padding: 1rem;
        margin-bottom: 1rem;
    }
    .data-preview {
        max-height: 300px;
        overflow-y: auto;
    }
</style>
""", unsafe_allow_html=True)

# Load models and configuration
@st.cache_resource
def load_models():
    model_dir = 'saved_models'

    # Load models
    lstm_model = load_model(os.path.join(model_dir, 'lstm_model.h5'))
    svr_model = joblib.load(os.path.join(model_dir, 'svr_model_tuned.pkl'))
    meta_model = joblib.load(os.path.join(model_dir, 'meta_model.pkl'))

    # Load scalers
    scaler_features = joblib.load(os.path.join(model_dir, 'scaler_features.pkl'))
    scaler_target = joblib.load(os.path.join(model_dir, 'scaler_target.pkl'))

    # Load configuration
    config = joblib.load(os.path.join(model_dir, 'model_config.pkl'))

    return lstm_model, svr_model, meta_model, scaler_features, scaler_target, config

# Load technical indicators function
def add_technical_indicators(df):
    """Calculates and adds technical indicators to the dataframe."""
    df_temp = df.copy()
    df_temp.set_index('Date', inplace=True)

    # Relative Strength Index (RSI)
    delta = df_temp['Close'].diff()
    gain = (delta.where(delta > 0, 0)).fillna(0)
    loss = (-delta.where(delta < 0, 0)).fillna(0)
    avg_gain = gain.ewm(span=14, adjust=False).mean()
    avg_loss = loss.ewm(span=14, adjust=False).mean()
    rs = avg_gain / avg_loss
    df_temp['RSI'] = 100 - (100 / (1 + rs))

    # Moving Average Convergence Divergence (MACD)
    exp1 = df_temp['Close'].ewm(span=12, adjust=False).mean()
    exp2 = df_temp['Close'].ewm(span=26, adjust=False).mean()
    df_temp['MACD'] = exp1 - exp2
    df_temp['MACD_signal'] = df_temp['MACD'].ewm(span=9, adjust=False).mean()

    # Stochastic Oscillator
    low_14 = df_temp['Low'].rolling(window=14).min()
    high_14 = df_temp['High'].rolling(window=14).max()
    df_temp['Stoch_K'] = ((df_temp['Close'] - low_14) / (high_14 - low_14)) * 100
    df_temp['Stoch_D'] = df_temp['Stoch_K'].rolling(window=3).mean()

    # Average True Range (ATR)
    high_low = df_temp['High'] - df_temp['Low']
    high_prev_close = np.abs(df_temp['High'] - df_temp['Close'].shift())
    low_prev_close = np.abs(df_temp['Low'] - df_temp['Close'].shift())
    tr = pd.concat([high_low, high_prev_close, low_prev_close], axis=1).max(axis=1)
    df_temp['ATR'] = tr.rolling(window=14).mean()

    # On-Balance Volume (OBV)
    df_temp['OBV'] = (np.sign(df_temp['Close'].diff()) * df_temp['Volume']).fillna(0).cumsum()

    df_temp.reset_index(inplace=True)
    return df_temp

# Prediction function
def predict_stock_price(ticker, start_date, end_date, geo_data, lstm_model, svr_model, meta_model,
                        scaler_features, scaler_target, config):
    # Fetch stock data
    stock_data = yf.download(ticker, start=start_date, end=end_date, interval="1d")
    stock_data = stock_data.reset_index()
    stock_data.columns = stock_data.columns.get_level_values(0)
    stock_data.dropna(inplace=True)

    # Add technical indicators
    stock_data = add_technical_indicators(stock_data)

    # Merge with geopolitical data
    stock_data.set_index('Date', inplace=True)
    stock_data_full = stock_data.join(geo_data, on='Date', how='left')
    stock_data_full.fillna(method='ffill', inplace=True)
    stock_data_full.dropna(inplace=True)

    # Select features
    data_features = stock_data_full[config['feature_columns']]

    # Scale features
    scaled_features = scaler_features.transform(data_features)

    # Prepare data for LSTM
    time_step = config['time_step']
    X_lstm = []
    for i in range(len(scaled_features) - time_step):
        X_lstm.append(scaled_features[i:(i + time_step)])
    X_lstm = np.array(X_lstm)

    # Prepare data for SVR
    X_svr = scaled_features[time_step:]

    # Make predictions
    lstm_pred = lstm_model.predict(X_lstm)
    svr_pred = svr_model.predict(X_svr)

    # Inverse transform predictions
    lstm_pred_inv = scaler_target.inverse_transform(lstm_pred)
    svr_pred_inv = scaler_target.inverse_transform(svr_pred.reshape(-1, 1))

    # Create meta features
    X_meta = pd.DataFrame({
        'LSTM_Pred': lstm_pred_inv.flatten(),
        'SVR_Pred': svr_pred_inv.flatten()
    })

    # Make final prediction with meta model
    hybrid_pred = meta_model.predict(X_meta)

    # Create results DataFrame
    results = pd.DataFrame({
        'Date': stock_data_full.index[time_step:],
        'Actual_Close': stock_data_full['Close'].values[time_step:],
        'Predicted_Close': hybrid_pred
    })

    return results, stock_data_full

# Main application
def main():
    # Header
    st.markdown('<h1 class="main-header">ðŸ“ˆ Stock Price Prediction Dashboard</h1>', unsafe_allow_html=True)
    st.markdown("### Predict stock prices using a hybrid LSTM-SVR model with technical indicators and geopolitical data")

    # Load models
    lstm_model, svr_model, meta_model, scaler_features, scaler_target, config = load_models()

    # Sidebar inputs
    st.sidebar.markdown("## Prediction Parameters")

    # Stock ticker input
    default_ticker = config['ticker']
    ticker = st.sidebar.text_input("Stock Ticker", value=default_ticker, max_chars=5).upper()

    # Date range selection
    end_date = datetime.now().date()
    start_date = end_date - timedelta(days=365)

    date_range = st.sidebar.date_input(
        "Select Date Range",
        value=(start_date, end_date),
        min_value=datetime(2015, 1, 1).date(),
        max_value=end_date
    )

    # Geopolitical data upload section
    st.sidebar.markdown("## Geopolitical Data Upload")
    st.sidebar.markdown("""
    <div class="file-uploader">
        <h4>Upload Geopolitical Data</h4>
        <p>Please upload a CSV file with the following columns:</p>
        <ul>
            <li><b>Date</b> (format: DD/MM/YYYY)</li>
            <li><b>GPRD</b> (Geopolitical Risk Raw Data)</li>
            <li><b>GPRD_ACT</b> (Geopolitical Risk Actual Threats)</li>
            <li><b>GPRD_THREAT</b> (Geopolitical Risk Threats)</li>
            <li><b>GPRD_MA30</b> (30-day Moving Average)</li>
            <li><b>GPRD_MA7</b> (7-day Moving Average)</li>
        </ul>
    </div>
    """, unsafe_allow_html=True)

    geo_data_file = st.sidebar.file_uploader(
        "Choose a CSV file",
        type=['csv'],
        key="geo_data_uploader"
    )

    # Default geopolitical data
    if geo_data_file is not None:
        try:
            # Read the uploaded file
            geo_data = pd.read_csv(geo_data_file)

            # Convert date column and set as index
            geo_data['Date'] = pd.to_datetime(geo_data['Date'], dayfirst=True)
            geo_data.set_index('Date', inplace=True)

            # Check if required columns are present
            required_columns = ['GPRD', 'GPRD_ACT', 'GPRD_THREAT', 'GPRD_MA30', 'GPRD_MA7']
            missing_columns = [col for col in required_columns if col not in geo_data.columns]

            if missing_columns:
                st.sidebar.error(f"Missing required columns: {', '.join(missing_columns)}")
                geo_data = None
            else:
                st.sidebar.success("Geopolitical data uploaded successfully!")

                # Show preview of uploaded data
                with st.expander("ðŸ“Š Uploaded Geopolitical Data Preview"):
                    st.markdown(f"**File:** {geo_data_file.name}")
                    st.markdown(f"**Rows:** {geo_data.shape[0]}, **Columns:** {geo_data.shape[1]}")
                    st.dataframe(geo_data.head(10), use_container_width=True)

        except Exception as e:
            st.sidebar.error(f"Error processing file: {str(e)}")
            geo_data = None
    else:
        st.sidebar.info("No file uploaded. Using default geopolitical data.")
        try:
            geo_data = pd.read_csv('geopolitical_data.csv')
            geo_data['Date'] = pd.to_datetime(geo_data['Date'], dayfirst=True)
            geo_data.set_index('Date', inplace=True)
        except FileNotFoundError:
            st.sidebar.error("Default geopolitical data file not found!")
            geo_data = None

    # Predict button
    predict_btn = st.sidebar.button("ðŸ”® Predict Stock Prices", type="primary", disabled=geo_data is None)

    # Main content
    if predict_btn and geo_data is not None:
        with st.spinner("Fetching data and making predictions..."):
            try:
                # Make predictions
                results, stock_data = predict_stock_price(
                    ticker, date_range[0], date_range[1], geo_data,
                    lstm_model, svr_model, meta_model,
                    scaler_features, scaler_target, config
                )

                # Display results
                st.markdown('<h2 class="sub-header">Prediction Results</h2>', unsafe_allow_html=True)

                # Key metrics
                col1, col2, col3 = st.columns(3)

                with col1:
                    last_actual = results['Actual_Close'].iloc[-1]
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>Last Actual Price</h4>
                        <h2>${last_actual:.2f}</h2>
                    </div>
                    """, unsafe_allow_html=True)

                with col2:
                    last_predicted = results['Predicted_Close'].iloc[-1]
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>Last Predicted Price</h4>
                        <h2>${last_predicted:.2f}</h2>
                    </div>
                    """, unsafe_allow_html=True)

                with col3:
                    price_diff = last_predicted - last_actual
                    price_diff_pct = (price_diff / last_actual) * 100
                    st.markdown(f"""
                    <div class="metric-card">
                        <h4>Prediction Difference</h4>
                        <h2>{price_diff_pct:.2f}%</h2>
                    </div>
                    """, unsafe_allow_html=True)

                # Prediction chart
                st.markdown('<h3 class="sub-header">Price Prediction Chart</h3>', unsafe_allow_html=True)

                fig = make_subplots(
                    rows=2, cols=1,
                    shared_xaxes=True,
                    vertical_spacing=0.1,
                    subplot_titles=(f'{ticker} Stock Price', 'Prediction Difference'),
                    row_width=[0.7, 0.3]
                )

                # Price chart
                fig.add_trace(
                    go.Scatter(
                        x=results['Date'],
                        y=results['Actual_Close'],
                        mode='lines',
                        name='Actual Price',
                        line=dict(color='blue', width=2)
                    ),
                    row=1, col=1
                )

                fig.add_trace(
                    go.Scatter(
                        x=results['Date'],
                        y=results['Predicted_Close'],
                        mode='lines',
                        name='Predicted Price',
                        line=dict(color='red', width=2, dash='dot')
                    ),
                    row=1, col=1
                )

                # Difference chart
                diff = results['Predicted_Close'] - results['Actual_Close']
                fig.add_trace(
                    go.Scatter(
                        x=results['Date'],
                        y=diff,
                        mode='lines',
                        name='Prediction Difference',
                        line=dict(color='green', width=2),
                        fill='tozeroy'
                    ),
                    row=2, col=1
                )

                fig.update_layout(
                    height=600,
                    hovermode='x unified',
                    legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
                )

                st.plotly_chart(fig, use_container_width=True)

                # Data table
                st.markdown('<h3 class="sub-header">Prediction Data</h3>', unsafe_allow_html=True)
                st.dataframe(results.sort_values('Date', ascending=False).head(20), use_container_width=True)

                # Model explanation
                with st.expander("ðŸ“– How the Prediction Works"):
                    st.markdown("""
                    This prediction uses a hybrid model combining:

                    1. **LSTM (Long Short-Term Memory)**: A neural network that captures temporal patterns in stock data
                    2. **SVR (Support Vector Regression)**: A machine learning model that captures non-linear relationships
                    3. **Meta-Model (Linear Regression)**: Combines predictions from LSTM and SVR for final output

                    The model uses:
                    - Historical price data (Open, High, Low, Close, Volume)
                    - Technical indicators (RSI, MACD, Stochastic Oscillator, ATR, OBV)
                    - Geopolitical risk data (GPRD indices)
                    """)

            except Exception as e:
                st.error(f"An error occurred: {str(e)}")
                st.info("Please check your inputs and try again.")

    # Footer
    st.markdown("---")
    st.markdown("Stock Price Prediction App | Built with Streamlit")

if __name__ == "__main__":
    main()